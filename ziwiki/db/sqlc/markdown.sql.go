// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: markdown.sql

package db

import (
	"context"
)

const createMarkdown = `-- name: CreateMarkdown :one
INSERT INTO markdowns (
  mdhref,
  user_id,
  repo_id,
  mdtext
) VALUES ($1, $2, $3, $4 ) 
RETURNING id, mdhref, user_id, repo_id, mdtext, created_at, fts
`

type CreateMarkdownParams struct {
	Mdhref string `json:"mdhref"`
	UserID int64  `json:"user_id"`
	RepoID int64  `json:"repo_id"`
	Mdtext string `json:"mdtext"`
}

func (q *Queries) CreateMarkdown(ctx context.Context, arg CreateMarkdownParams) (Markdown, error) {
	row := q.db.QueryRowContext(ctx, createMarkdown,
		arg.Mdhref,
		arg.UserID,
		arg.RepoID,
		arg.Mdtext,
	)
	var i Markdown
	err := row.Scan(
		&i.ID,
		&i.Mdhref,
		&i.UserID,
		&i.RepoID,
		&i.Mdtext,
		&i.CreatedAt,
		&i.Fts,
	)
	return i, err
}

const deleteMarkdown = `-- name: DeleteMarkdown :exec
DELETE FROM markdowns
WHERE mdhref = $1 and user_id = $2 and repo_id = $3
`

type DeleteMarkdownParams struct {
	Mdhref string `json:"mdhref"`
	UserID int64  `json:"user_id"`
	RepoID int64  `json:"repo_id"`
}

func (q *Queries) DeleteMarkdown(ctx context.Context, arg DeleteMarkdownParams) error {
	_, err := q.db.ExecContext(ctx, deleteMarkdown, arg.Mdhref, arg.UserID, arg.RepoID)
	return err
}

const deleteMarkdownByRepo = `-- name: DeleteMarkdownByRepo :exec
DELETE FROM markdowns
WHERE user_id = $1 and repo_id = $2
`

type DeleteMarkdownByRepoParams struct {
	UserID int64 `json:"user_id"`
	RepoID int64 `json:"repo_id"`
}

func (q *Queries) DeleteMarkdownByRepo(ctx context.Context, arg DeleteMarkdownByRepoParams) error {
	_, err := q.db.ExecContext(ctx, deleteMarkdownByRepo, arg.UserID, arg.RepoID)
	return err
}

const getMarkdown = `-- name: GetMarkdown :one
SELECT id, mdhref, user_id, repo_id, mdtext, created_at, fts FROM markdowns
WHERE mdhref = $1 and user_id = $2 and repo_id = $3 LIMIT 1
`

type GetMarkdownParams struct {
	Mdhref string `json:"mdhref"`
	UserID int64  `json:"user_id"`
	RepoID int64  `json:"repo_id"`
}

func (q *Queries) GetMarkdown(ctx context.Context, arg GetMarkdownParams) (Markdown, error) {
	row := q.db.QueryRowContext(ctx, getMarkdown, arg.Mdhref, arg.UserID, arg.RepoID)
	var i Markdown
	err := row.Scan(
		&i.ID,
		&i.Mdhref,
		&i.UserID,
		&i.RepoID,
		&i.Mdtext,
		&i.CreatedAt,
		&i.Fts,
	)
	return i, err
}

const getMarkdownForUpdate = `-- name: GetMarkdownForUpdate :one
SELECT id, mdhref, user_id, repo_id, mdtext, created_at, fts FROM markdowns
WHERE mdhref = $1 and user_id = $2 and repo_id = $3 LIMIT 1
FOR NO KEY UPDATE
`

type GetMarkdownForUpdateParams struct {
	Mdhref string `json:"mdhref"`
	UserID int64  `json:"user_id"`
	RepoID int64  `json:"repo_id"`
}

func (q *Queries) GetMarkdownForUpdate(ctx context.Context, arg GetMarkdownForUpdateParams) (Markdown, error) {
	row := q.db.QueryRowContext(ctx, getMarkdownForUpdate, arg.Mdhref, arg.UserID, arg.RepoID)
	var i Markdown
	err := row.Scan(
		&i.ID,
		&i.Mdhref,
		&i.UserID,
		&i.RepoID,
		&i.Mdtext,
		&i.CreatedAt,
		&i.Fts,
	)
	return i, err
}

const queryMarkdownRepo = `-- name: QueryMarkdownRepo :many
select i.id,i.mdhref,i.user_id,i.repo_id,COALESCE(ts_headline(i.mdtext,plainto_tsquery($1),'MaxFragments=10, MaxWords=7, MinWords=3'),'')
from (
  select id,mdhref,user_id,repo_id,mdtext,ts_rank(fts, plainto_tsquery($1)) as rank
  from markdowns 
  where user_id = $2 and repo_id=$3  and fts @@ plainto_tsquery($1)
  ORDER BY
    rank DESC
  LIMIT 20
) as i
ORDER BY
  i.rank DESC
`

type QueryMarkdownRepoParams struct {
	PlaintoTsquery string `json:"plainto_tsquery"`
	UserID         int64  `json:"user_id"`
	RepoID         int64  `json:"repo_id"`
}

type QueryMarkdownRepoRow struct {
	ID       int64       `json:"id"`
	Mdhref   string      `json:"mdhref"`
	UserID   int64       `json:"user_id"`
	RepoID   int64       `json:"repo_id"`
	Coalesce interface{} `json:"coalesce"`
}

func (q *Queries) QueryMarkdownRepo(ctx context.Context, arg QueryMarkdownRepoParams) ([]QueryMarkdownRepoRow, error) {
	rows, err := q.db.QueryContext(ctx, queryMarkdownRepo, arg.PlaintoTsquery, arg.UserID, arg.RepoID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QueryMarkdownRepoRow{}
	for rows.Next() {
		var i QueryMarkdownRepoRow
		if err := rows.Scan(
			&i.ID,
			&i.Mdhref,
			&i.UserID,
			&i.RepoID,
			&i.Coalesce,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryMarkdownUser = `-- name: QueryMarkdownUser :many
select i.id,i.mdhref,i.user_id,i.repo_id,COALESCE(ts_headline(i.mdtext,plainto_tsquery($1),'MaxFragments=10, MaxWords=7, MinWords=3'),'')
from (
  select id,mdhref,user_id,repo_id,mdtext,ts_rank(fts, plainto_tsquery($1)) as rank
  from markdowns 
  where user_id = $2  and fts @@ plainto_tsquery($1)
  ORDER BY
    rank DESC
  LIMIT 20
) as i
ORDER BY
  i.rank DESC
`

type QueryMarkdownUserParams struct {
	PlaintoTsquery string `json:"plainto_tsquery"`
	UserID         int64  `json:"user_id"`
}

type QueryMarkdownUserRow struct {
	ID       int64       `json:"id"`
	Mdhref   string      `json:"mdhref"`
	UserID   int64       `json:"user_id"`
	RepoID   int64       `json:"repo_id"`
	Coalesce interface{} `json:"coalesce"`
}

func (q *Queries) QueryMarkdownUser(ctx context.Context, arg QueryMarkdownUserParams) ([]QueryMarkdownUserRow, error) {
	rows, err := q.db.QueryContext(ctx, queryMarkdownUser, arg.PlaintoTsquery, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QueryMarkdownUserRow{}
	for rows.Next() {
		var i QueryMarkdownUserRow
		if err := rows.Scan(
			&i.ID,
			&i.Mdhref,
			&i.UserID,
			&i.RepoID,
			&i.Coalesce,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMarkdown = `-- name: UpdateMarkdown :one
UPDATE markdowns
SET mdtext=$4
WHERE mdhref = $1 and user_id = $2 and repo_id = $3
RETURNING id, mdhref, user_id, repo_id, mdtext, created_at, fts
`

type UpdateMarkdownParams struct {
	Mdhref string `json:"mdhref"`
	UserID int64  `json:"user_id"`
	RepoID int64  `json:"repo_id"`
	Mdtext string `json:"mdtext"`
}

func (q *Queries) UpdateMarkdown(ctx context.Context, arg UpdateMarkdownParams) (Markdown, error) {
	row := q.db.QueryRowContext(ctx, updateMarkdown,
		arg.Mdhref,
		arg.UserID,
		arg.RepoID,
		arg.Mdtext,
	)
	var i Markdown
	err := row.Scan(
		&i.ID,
		&i.Mdhref,
		&i.UserID,
		&i.RepoID,
		&i.Mdtext,
		&i.CreatedAt,
		&i.Fts,
	)
	return i, err
}
